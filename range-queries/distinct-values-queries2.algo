ogni nodo ha
- distinct (numero di valori distinti)
- rlim, llim i limiti entro il quale ha duplicati
distinct = llim < l && rlim > r


Fare una map<elemento, set<posizioni>>
tenere una lista di range "proibiti".

Ragiona sulla sliding window: 
Un run della sliding window risolve tutte le query in tempo O(n), ma non gestisce gli update
Un update di quanto fa cambiare la sliding window?
Encoda la sliding window come st[l].rlim
Query l, r => verifica se st[l].rlim >= r
Update i, x => trova il prossimo indice j = x, metti rlim a j
	Problema: non puoi fare merge bene dei pezzi prima, i valori dipendono da roba esterna ai range

Ritorniamo al segment tree:
	prendi massimo range distinto prefisso e suffisso e massimo range interno (stile sub sum queries)
	merge : devi verificare che i r.pref e l.suff non abbiano cose in comune : merge sort tree!
	Tieni coppie val, ind nell'array da sortare, così da avere il right e left bound facili da creare
	Il centro è sempre un unione di un right con un left.
	OK MA SE FAI UN MERGE SORT PER OGNI QUERY E SEMPRE O(N) PORCODIO


segna solo il next-index dei vari nodi.
v(i) = x => cambia v(i).next alla prossima occorrenza di x (inf se non esiste)
cambia anche la precedente occorrenza di x a i.
Entrambe possibili usando map<x, set<int> di occorrenze>



